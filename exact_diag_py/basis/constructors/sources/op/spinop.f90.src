
subroutine <name=s,d,c,z>_SpinOp(basis,Ns,opstr,indx,N_indx,col,ME,error)
implicit none
integer(kind=4), intent(in) :: Ns,N_indx
integer(kind=4), intent(in), dimension(Ns) :: basis
integer(kind=4), intent(in), dimension(N_indx) :: indx
character, intent(in), dimension(N_indx) :: opstr
<real(kind=4),real(kind=8),complex(kind=4),complex(kind=8)>, intent(out), dimension(Ns) :: ME
integer(kind=4), intent(out), dimension(Ns) :: col
integer(kind=4), intent(out) :: error
<complex(kind=4),complex(kind=8),complex(kind=4),complex(kind=8)> :: M_E
integer(kind=4) :: i,j,r,a


error=0
do i=1,Ns
M_E=1.0<d0=,d0,,d0>; r=basis(i)
do j=N_indx,1,-1
a = iand(ishft(r,-indx(j)),1)
if(opstr(j) .eq. "c") then
cycle

else if(opstr(j) .eq. "z") then
M_E = M_E * (-1.0<d0>)**(a+1)

else if(opstr(j) .eq. "x") then
r = ieor(r,ishft(1,indx(j)))

else if(opstr(j) .eq. "y") then
r = ieor(r,ishft(1,indx(j)))
M_E = M_E * (-1.0<d0>)**(a)*<cmplx,dcmplx,cmplx,dcmplx>(0.0,1.0<d0>)

else if(opstr(j) .eq. "+") then
if (a .eq. 1) then 
r=basis(i); M_E=0.0<d0>;
exit
else
r = ieor(r,ishft(1,indx(j)))
M_E = M_E * 2.0<d0>
end if

else if(opstr(j) .eq. "-") then
if (a .eq. 0) then 
r=basis(i); M_E=0.0<d0>;
exit
else
r = ieor(r,ishft(1,indx(j)))
M_E = M_E * 2.0<d0>
end if

else
ME=0<d0>;col=0;error=1
return 

end if

end do

if(<aimag,dimag,aimag,dimag>(M_E) .ne. 0.0<d0> .and. <.true.,.true.,.false.,.false.>) then
ME=0<d0>;col=0;error=-1
return 
end if

ME(i)=<real,dble,cmplx,dcmplx>(M_E)
col(i)=r

end do

end subroutine




