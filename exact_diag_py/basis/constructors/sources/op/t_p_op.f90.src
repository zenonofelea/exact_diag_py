subroutine refstate_t_p(s,L,a,ll,q)
implicit none
integer(kind=4), intent(in) :: L,a
integer(kind=8), intent(inout) :: s
integer(kind=4), intent(out) :: ll,q
integer(kind=8) :: r,t
integer(kind=4) :: i

ll = 0; q = 0
r = s; t = s
do i=1,L/a
t=ishftc(t,-a,L)
if(t.lt.r) then
ll = i; r = t
end if
end do

t = s
call flip_lr(t,L)
do i=1,L/a
t=ishftc(t,-a,L)
if(t.lt.r) then
q = 1; ll = i; r = t
end if
end do

s = r

end subroutine







subroutine <name=s,d,c,z>_t_p_op(N,m,basis,Ns,opstr,indx,N_indx,L,pblock,kblock,a,col,ME,error)
implicit none
<re_type=real(kind=4),real(kind=8),real(kind=4),real(kind=8)>, parameter :: pi=4.0<d0=,d0,,d0>*<d=,d,,d>atan(1.0<d0>)
<cp_type=complex(kind=4),complex(kind=8),complex(kind=4),complex(kind=8)>, parameter :: i=<d>cmplx(0.0,1.0<d0>)
integer(kind=4), intent(in) :: Ns, N_indx, L, pblock, kblock, a
integer(kind=4), intent(in), dimension(N_indx) :: indx
character, intent(in), dimension(N_indx) :: opstr
integer(kind=1), intent(in), dimension(Ns) :: N,m
integer(kind=4), intent(in), dimension(Ns) :: basis
integer(kind=4), intent(out), dimension(2*Ns) :: col
<type=real(kind=4),real(kind=8),complex(kind=4),complex(kind=8)>, intent(out), dimension(2*Ns) :: ME
integer(kind=4), intent(out) :: error
integer(kind=4), external :: FindZstate,zrm
integer(kind=8), external :: zext
integer(kind=8) :: s_8
<re_type>, external :: <name2=s,d,s,d>_helement_p
<re_type> :: k
<cp_type> :: M_E
integer(kind=4) :: j,s,ll,q
integer(kind=4) :: jj,b,c,o,p

ME = 0.0<d0>
col = -1
call <name>_spinop(basis,Ns,opstr,indx,N_indx,col,ME,error)

ME(Ns+1:2*Ns)=ME(1:Ns)


if(error .ne. 0) return

k=(2*pi*a*kblock)/L

if(<d>abs(<d>sin(k)) .le. epsilon(1.0<d0>)) then ! if in k=0 or pi block

do j=1,Ns
s_8 = zext(col(j))
call refstate_t_p(s_8,L,a,ll,q)
s = zrm(s_8)
s = FindZstate(basis,Ns,s)

if(s.lt.0) then
col(j) = -1
cycle
end if



M_E = ME(j)*<name2>_helement_p(N(j),m(j),N(s),m(s),pblock,k,q,ll)

if(<aimag,dimag,aimag,dimag>(M_E) .ne. 0.0<d0> .and. <.true.,.true.,.false.,.false.>) then
ME = 0.0<d0>; col=1 ;error=-1
return 
else
ME(j) = <real,dble,cmplx,dcmplx>(M_E)
col(j) = s
end if

end do

else ! not in k=0 or pi block

do j=1,Ns

if((j .gt. 1) .and. (basis(j) .eq. basis(j-1))) then ! checking to see if this is the first representative of a pair of semi-momentum states
cycle
else if((j .lt. Ns) .and. (basis(j) .eq. basis(j+1))) then
o=2
else
o=1
end if

s_8 = zext(col(j))
call refstate_t_p(s_8,L,a,ll,q)
s = zrm(s_8)
s = FindZstate(basis,Ns,s)


if(s .lt. 0) then
do jj=j,j+o-1
col(jj)=-1
end do
cycle
end if

if((s.eq.j).and.(q.eq.0).and.(ll.eq.0)) then ! if matrix element is diagonal

do jj=j,j+o-1
M_E = <name2>_helement_p(N(jj),m(jj),N(jj),m(jj),pblock,k,q,ll) * ME(jj)

if(<aimag,dimag,aimag,dimag>(M_E) .ne. 0.0<d0> .and. <.true.,.true.,.false.,.false.>) then
ME = 0.0<d0>; col=1 ;error=-1
return
end if 
ME(jj) = <real,dble,cmplx,dcmplx>(M_E)
col(jj) = jj

end do

else ! not diagonal



! checking to see if this is the first representative of a pair of semi-momentum states
if((s .gt. 1) .and. (basis(s) .eq. basis(s-1))) then 
s = s - 1
p = 2
else if((s .lt. Ns) .and. (basis(s) .eq. basis(s+1))) then
p = 2
else
p = 1
end if


do c=0,o-1
do b=0,p-1

jj=j+c+b*Ns
M_E = <name2>_helement_p(N(j+c),m(j+c),N(s+b),m(s+b),pblock,k,q,ll) * ME(jj)

if(<aimag,dimag,aimag,dimag>(M_E) .ne. 0.0<d0> .and. <.true.,.true.,.false.,.false.>) then
ME=0.0<d0>; col=1 ;error=-1
return 
end if

col(jj)=s+b
ME(jj) = <real,dble,cmplx,dcmplx>(M_E)
!if(((j+c).eq.1.and.(s+b).eq.3).or.((j+c).eq.3.and.(s+b).eq.1))then
!print*, o,p,N(j+c),N(s+b),m(s+b),q,ll
!print*, j+c,s+b,ME(jj)
!print*,
!end if

end do
end do


end if ! end matrix element is diagonal
end do
end if ! end in k=0 or pi block

!print*, col


end subroutine



function <name=s,d>_helement_p(N_a,m_a,N_b,m_b,pblock,k,q,ll)
implicit none
! i: row index
! j: col index
<re_type=real(kind=4),real(kind=8)> :: <name>_helement_p
integer(kind=4), intent(in) :: pblock,q,ll
integer(kind=1), intent(in) :: N_a,m_a,N_b,m_b
<re_type>,intent(in) :: k
integer(kind=4) :: sigma_a,sigma_b

<re_type> :: norm_a,norm_b,bc,N_ratio
<re_type>, external :: <name>_norm_p

sigma_a = sign(1,int(N_a,4))
sigma_b = sign(1,int(N_b,4))

norm_a = <name>_norm_p(k,pblock,N_a,m_a)
norm_b = <name>_norm_p(k,pblock,N_b,m_b)

N_ratio = <d=,d>sqrt(<d>abs(norm_b/norm_a))

if(sigma_a .eq. sigma_b) then
if( m_b .lt. 0)then
bc=<d>cos(k*ll)
else
bc=(<d>cos(k*ll) + sigma_a*pblock*<d>cos(k*(ll-m_b)))/(1.0<d0=,d0> + sigma_a*pblock*<d>cos(k*m_b))
end if
else
if( m_b .lt. 0)then
bc=-sigma_a*<d>sin(k*ll)
else
bc=(-sigma_a*<d>sin(k*ll) + pblock*<d>sin(k*(ll-m_b)))/(1.0<d0> - sigma_a*pblock*<d>cos(k*m_b))
end if
end if

<name>_helement_p = ((sigma_a*pblock)**q)*N_ratio*bc

end function





function <name=s,d>_norm_p(k,pblock,N,m)
implicit none
<re_type=real(kind=4),real(kind=8)> :: <name>_norm_p
integer(kind=1), intent(in) :: N,m
integer(kind=4), intent(in) :: pblock
<re_type>, intent(in) :: k

if(m .ge. 0) then
<name>_norm_p = (1.0<d0=,d0> + sign(1,int(N,4))*pblock*<,d>cos(k*m))/N
else
<name>_norm_p =  1.0<d0>/N
end if

end function
