subroutine refstate_t(s,L,a,ll)
implicit none
integer(kind=4), intent(in) :: L,a
integer(kind=8), intent(inout) :: s
integer(kind=4), intent(out) :: ll
integer(kind=8) :: r,t
integer(kind=4) :: i

ll=0
r = s
t = s

do i=1,L/a
t=ishftc(t,-a,L)
if(t.lt.r) then
ll = i; r = t
end if
end do

s = r


end subroutine



subroutine <name=s,d,c,z>_t_op(N,basis,Ns,opstr,indx,N_indx,L,kblock,a,col,ME,error)
implicit none
<re_type=real(kind=4),real(kind=8),real(kind=4),real(kind=8)>, parameter :: pi=4.0<d0=,d0,,d0>*<d=,d,,d>atan(-1.0<d0>)
<cp_type=complex(kind=4),complex(kind=8),complex(kind=4),complex(kind=8)>, parameter :: i=<d>cmplx(0.0,1.0<d0>)
integer(kind=4), intent(in) :: Ns, N_indx, L, kblock, a
integer(kind=4), intent(in), dimension(N_indx) :: indx
character, intent(in), dimension(N_indx) :: opstr
integer(kind=4), intent(in), dimension(Ns) :: basis
integer(kind=1), intent(in), dimension(Ns) :: N
integer(kind=4), intent(out), dimension(Ns) :: col
<type=real(kind=4),real(kind=8),complex(kind=4),complex(kind=8)>, intent(out), dimension(Ns) :: ME
integer(kind=4), intent(out) :: error
integer(kind=4), external :: FindZstate,zrm
integer(kind=8), external :: zext
integer(kind=8) :: s_8
<re_type> :: k
<cp_type> :: M_E
integer(kind=4) :: j,s,ll


call <name>_spinop(basis,Ns,opstr,indx,N_indx,col,ME,error)

if(error .ne. 0) return

k=(2*pi*a*kblock)/L

do j=1,Ns

s_8 = zext(col(j))
call refstate_t(s_8,L,a,ll)
s = zrm(s_8)
s = FindZstate(basis,Ns,s)
col(j)=s

if(s.ge.0) then
M_E = ME(j)*<,d,,d>sqrt(<con=float,dble,float,dble>(N(j))/<con>(N(s)))*<c,z,c,z>exp(-i*k*ll)

if(<aimag,dimag,aimag,dimag>(M_E) .ne. 0.0<d0> .and. <.true.,.true.,.false.,.false.>) then
ME = 0.0<d0>; col=1 ;error=-1
return 
else
ME(j) = <real,dble,cmplx,dcmplx>(M_E)
end if

endif

end do

end subroutine





