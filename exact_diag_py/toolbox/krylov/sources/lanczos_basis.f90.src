











subroutine <name=s,d,c,z>_lanczos_op(m,col,nm,rowptr,nr,v_in,n,tol,ncv_max,a,b,ncv,stat)
implicit none
integer(kind=4), intent(in) :: nm,nr,n,ncv_max
<type=real(kind=4),real(kind=8),complex(kind=4),complex(kind=8)>, intent(in), dimension(nm) :: m
integer(kind=4), intent(in), dimension(nm) :: col
integer(kind=4), intent(in), dimension(nr) :: rowptr
<type>, intent(in), dimension(n) :: v_in
<abstype = real(kind=4),real(kind=8),real(kind=4),real(kind=8)>, intent(in) :: tol
<abstype>, intent(out), dimension(ncv_max) :: a
<abstype>, intent(out), dimension(ncv_max-1) :: b
integer(kind=4), intent(out) :: stat,ncv
! local variables
<type>, dimension(n) :: q,r,w
integer(kind=4) :: j
<abstype> :: log_prod_b, log_fact, a_sum, log_tol

stat = -1
b = 0.0<ending=,d0,,d0>
a = 0.0<ending>

log_tol = <func1=,d,,d>log(tol)
log_fact = <func1>log(2.0<ending>)

q = v_in
call <name>_csr_dot(m,col,nm,rowptr,nr,q,r,n)

a(1) = <convert=real,dble,real,dble>(dot_product(q,r))
r = r - a(1) * q
b(1) = <func1>sqrt(<func2=,d,c,z>abs(dot_product(r,r)))

log_prod_b = <func1>log( b(1) )
a_sum = <func1>abs(a(1))
 
j = 2
do while((j .lt. ncv_max-1) .and. (stat .lt. 0<ending>))
w = q 
q = r/b(j-1)
call <name>_csr_dot(m,col,nm,rowptr,nr,q,r,n)
r = r - b(j-1) * w
a(j) = <convert>(dot_product(q,r))
r = r - a(j) * q

b(j) = <func1>sqrt(<func2>abs(dot_product(r,r)))
log_fact = log_fact + <func1>log(<convert>(j+1))
a_sum = a_sum + <func1>abs(a(j))

if( b(j) .gt. 0.0<ending>) then
log_prod_b = log_prod_b + <func1>log( b(j) )
else if( b(j) .eq. 0.0<ending> )then
stat = 1
j = j + 1
exit
end if


j = j + 1
!print*,  <func1>log(a_sum) + log_prod_b - log_fact, log_tol
if( ( ( <func1>log(a_sum) + log_prod_b - log_fact) .lt. log_tol ) .and. (j .ge. 2) ) then
stat=0
exit
end if

end do

w = q 
q = r/b(j-1)
call <name>_csr_dot(m,col,nm,rowptr,nr,q,r,n)
r = r - b(j-1) * w
a(j) = <convert>(dot_product(q,r))
ncv = j



 
end subroutine














subroutine <name>_get_vec(m,col,nm,rowptr,nr,v_l,a,b,ncv,v_in,n,v_out)
implicit none
integer(kind=4), intent(in) :: nm,nr,n,ncv
<type>, intent(in), dimension(nm) :: m
integer(kind=4), intent(in), dimension(nm) :: col
integer(kind=4), intent(in), dimension(nr) :: rowptr
<type>, intent(in), dimension(n) :: v_in
<type>, intent(in), dimension(ncv) :: v_l
<abstype>, intent(in), dimension(ncv) :: a
<abstype>, intent(in), dimension(ncv-1) :: b
<type>, intent(out), dimension(n) :: v_out
! local variables
<type>, dimension(n) :: q,r,w
integer(kind=4) :: j

q = v_in

v_out = v_out + v_l(1) * q
call <name>_csr_dot(m,col,nm,rowptr,nr,q,r,n)
r = r - a(1) * q

do j = 2, ncv - 1
w = q 
q = r/b(j-1)
v_out = v_out + v_l(j) * q
call <name>_csr_dot(m,col,nm,rowptr,nr,q,r,n)
r = r - b(j-1) * w - a(j) * q
end do
 
w = q 
q = r/b(ncv-1)
v_out = v_out + v_l(ncv) * q
 
end subroutine









subroutine <name>_csr_dot(a,col,na,rowptr,nr,v_in,v_out,n)
implicit none
integer(kind=4), intent(in) :: na,nr,n
<type>, intent(in), dimension(0:na-1) :: a
integer(kind=4), intent(in), dimension(0:na-1) :: col
integer(kind=4), intent(in), dimension(0:nr-1) :: rowptr
<type>, intent(in), dimension(0:n-1) :: v_in
<type>, intent(out), dimension(0:n-1) :: v_out
integer(kind=4) :: i,j
 
v_out=0.0
 
do i = 0, n - 1
do j = rowptr(i), rowptr(i+1) - 1
v_out(i) = v_out(i) + A(j) * v_in(col(j))
end do
end do
 
end subroutine














!subroutine <name>_get_basis(m,col,nm,rowptr,nr,a,b,ncv,v_in,n,v)
!implicit none
!integer(kind=4), intent(in) :: nm,nr,n,ncv
!<type>, intent(in), dimension(nm) :: m
!integer(kind=4), intent(in), dimension(nm) :: col
!integer(kind=4), intent(in), dimension(nr) :: rowptr
!<type>, intent(in), dimension(n) :: v_in
!<abstype>, intent(in), dimension(ncv) :: a
!<abstype>, intent(in), dimension(ncv-1) :: b
!<type>, intent(out), dimension(n,ncv) :: v
! local variables
!<type>, dimension(n) :: q,r,w
!integer(kind=4) :: j
!v(:,1) = v_in
!q = v_in
!call <name>_csr_dot(m,col,nm,rowptr,nr,q,r,n)
!r = r - a(1) * q
!do j = 2, ncv - 1
!w = q 
!q = r/b(j-1)
!v(:,j) = q
!call <name>_csr_dot(m,col,nm,rowptr,nr,q,r,n)
!r = r - b(j-1) * w - a(j) * q
!end do
!w = q 
!q = r/b(ncv-1)
!v(:,ncv) = q
!end subroutine









!subroutine <name>_full_orthogonal(v,n,p,r,w)
!implicit none
!integer(kind=4), intent(in) :: n,p
!<type>, intent(in), dimension(n,p) :: v
!<type>, intent(in), dimension(n) :: r
!<type>, intent(out), dimension(n) :: w
!<type>, dimension(p) :: rw
!rw = matmul(transpose(<v,v,conjg(v),dconjg(v)>),r)
!w = matmul(v,rw)
!end subroutine






