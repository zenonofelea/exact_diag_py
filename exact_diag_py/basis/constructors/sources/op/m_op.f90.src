
subroutine <name=s,d,c,z>_m_op(basis,Ns,opstr,indx,N_indx,col,ME,error)
implicit none
integer(kind=4), intent(in) :: Ns, N_indx
integer(kind=4), intent(in), dimension(N_indx) :: indx
character, intent(in), dimension(N_indx) :: opstr
integer(kind=4), intent(in), dimension(Ns) :: basis
integer(kind=4), intent(out), dimension(Ns) :: col
<real(kind=4),real(kind=8),complex(kind=4),complex(kind=8)>, intent(out), dimension(Ns) :: ME
integer(kind=4), intent(out) :: error
integer(kind=4), external :: FindZstate
integer(kind=4) :: i


call <name>_spinop(basis,Ns,opstr,indx,N_indx,col,ME,error)

if(error .ne. 0) then
return
end if

do i=1,Ns
col(i) = FindZstate(basis,Ns, col(i))
end do

end subroutine



function FindZstate(A,N,s)
implicit none
integer(kind=4) :: FindZstate
integer(kind=4), intent(in) :: N, s
integer(kind=4), intent(in), dimension(N) :: A
integer(kind=8), external :: zext ! converts the 32 bit configuration to 64 bit for comparisons
integer(kind=8) :: s_l,A_l
integer(kind=4) :: bmin,bmax,b

bmin=1;bmax=N
s_l = zext(s)
do while(bmin .le. bmax)
b=(bmin+bmax)/2
A_l = zext(A(b))
if(s_l < A_l) then
bmax=b-1
else if(s_l > A_l) then
bmin=b+1
else
FindZstate=b
return 
end if
end do
FindZstate=-1
end function





function zext(b)
implicit none
integer(kind=4), intent(in) :: b
integer(kind=8) :: zext
integer(kind=1) :: i

zext = 0_8
do i=0,31
if(btest(b,i)) zext = zext + ishft(1_8,i)
end do 


end function zext


function zrm(b)
implicit none
integer(kind=8), intent(in) :: b
integer(kind=4) :: zrm
integer(kind=1) :: i

zrm = 0
do i=0,31
if(btest(b,i)) zrm = zrm + ishft(1,i)
end do 


end function zrm
