subroutine checkstate_t_p_z(s,L,k,a,N,mp,mz,mpz)
implicit none
integer(kind=8), intent(in) :: s
integer(kind=4), intent(in) :: L,k,a
integer(kind=1), intent(out) :: N
integer(kind=2), intent(out) :: mz,mp,mpz
integer(kind=8) :: t
integer(kind=4) :: i,NN

t=s
N=-1
mp=-1
mz=-1
mpz=-1

do i=1,L/a
t=ishftc(t,-a,L)
if ( t .lt. s ) then
return
else if ( t .eq. s) then 
if ( modulo(k,(L/(a*int(i)))) .ne. 0) then
return
end if
N=int(i,1)
exit
end if
end do



NN = i
t = s
call flip_lr_64(t,L)

do i=0,NN-1
if (t .lt. s) then
N = -1
return
else if(t .eq. s) then
mp = int(i,2)
exit
end if
t = ishftc(t,-a,L)
end do



t = s
call flip_all_64(t,L)

do i=0,NN-1
if (t .lt. s) then
N = -1
return
else if(t .eq. s) then
mz = int(i,2)
exit
end if
t = ishftc(t,-a,L)
end do


t = s
call flip_lr_64(t,L)
call flip_all_64(t,L)

do i=0,NN-1
if (t .lt. s) then
N = -1
return
else if(t .eq. s) then
mpz = int(i,2)
return
end if
t = ishftc(t,-a,L)
end do


end subroutine














subroutine make_t_p_z_basis(L,pblock,zblock,kblock,a,N,m,basis,Ns,Ns_out)
implicit none
real(kind=8), parameter :: pi = 4.0d0*datan(1.0d0)
integer(kind=4), intent(in) :: L,pblock,zblock,kblock,a,Ns
integer(kind=4), intent(inout), dimension(Ns) :: basis
integer(kind=1), intent(inout), dimension(Ns) :: N
integer(kind=2), intent(inout), dimension(Ns) :: m
integer(kind=4), intent(out) :: Ns_out
integer(kind=8), external :: zext
integer(kind=8) :: s_8
real(kind=8) :: n1,n2,n3,n4
integer(kind=4) :: s,i,f
integer(kind=2) :: mp,mz,mpz
integer(kind=1) :: NN_temp,NN,sigma,sigma_i,sigma_f

if(L == 32) then
i = -huge(1) -1
f = huge(1)
else
i = 0
f = ishft(1,L) - 1
end if

if(dabs(dsin(2*kblock*a*pi/L)) .le. epsilon(1.0d0)) then
sigma_i=1
sigma_f=1
else
sigma_i=-1
sigma_f=1
end if


Ns_out = 0
do s=i,f

s_8 = zext(s)
call CheckState_t_p_z(s_8,L,kblock,a,NN,mp,mz,mpz)

if (NN .ge. 0) then
if((mp .eq. -1) .and. (mz .eq. -1) .and. (mpz .eq. -1)) then

do sigma=sigma_i,sigma_f,2
Ns_out = Ns_out + 1
basis(Ns_out) = s
N(Ns_out) = sigma*NN
m(Ns_out) = int((L+1)**2,2)
end do

else if((mp .ne. -1) .and. (mz .eq. -1) .and. (mpz .eq. -1)) then

do sigma=sigma_i,sigma_f,2
NN_temp = NN

n1=1.0d0 + sigma*pblock*dcos(2*kblock*mp*a*pi/L)
n2=1.0d0 - sigma*pblock*dcos(2*kblock*mp*a*pi/L)

if (n1  .eq. 0.0d0) NN_temp = -1
if((sigma .eq. -1) .and. (n2 .ne. 0.0d0)) NN_temp = -1

if(NN_temp .ge. 0) then
Ns_out = Ns_out + 1
basis(Ns_out) = s
N(Ns_out) = sigma*NN_temp
m(Ns_out) = mp + int(2*(L+1)**2,2)
end if
end do

else if((mp .eq. -1) .and. (mz .ne. -1) .and. (mpz .eq. -1)) then

do sigma=sigma_i,sigma_f,2
NN_temp=NN
n1=1.0d0 + zblock*dcos(2*kblock*mz*a*pi/L)
if ( n1 .eq. 0.0d0) NN_temp = -1

if(NN_temp .ge. 0) then
Ns_out = Ns_out + 1
basis(Ns_out) = s
N(Ns_out) = sigma*NN_temp
m(Ns_out) = mz*int(L+1,2) + int(3*(L+1)**2,2)
end if
end do

else if((mp .eq. -1) .and. (mz .eq. -1) .and. (mpz .ne. -1)) then

do sigma=sigma_i,sigma_f,2
NN_temp = NN

n1=1.0d0 + sigma*zblock*pblock*dcos(2*kblock*mpz*a*pi/L)
n2=1.0d0 - sigma*zblock*pblock*dcos(2*kblock*mpz*a*pi/L)
if (n1  .eq. 0.0d0) NN_temp = -1
if((sigma .eq. -1) .and. (n2 .ne. 0.0d0)) NN_temp = -1

if(NN_temp .ge. 0) then
Ns_out = Ns_out + 1
basis(Ns_out) = s
N(Ns_out) = sigma*NN_temp
m(Ns_out) = mpz + int(4*(L+1)**2,2)
end if
end do

else if((mp .ne. -1) .and. (mz .ne. -1)) then

do sigma=sigma_i,sigma_f,2
NN_temp = NN

n1=1.0d0 + zblock*dcos(2*kblock*mz*a*pi/L)
n2=1.0d0 + sigma*pblock*dcos(2*kblock*mp*a*pi/L)
n3=1.0d0 - zblock*dcos(2*kblock*mz*a*pi/L)
n4=1.0d0 - sigma*pblock*dcos(2*kblock*mp*a*pi/L)

if((n1  .eq. 0.0d0) .or. (n2  .eq. 0.0d0)) NN_temp = -1
if((sigma .eq. -1) .and. ((n3 .ne. 0.0d0) .or. (n4 .ne. 0.0d0))) NN_temp = -1

if(NN_temp .ge. 0) then
Ns_out = Ns_out + 1
basis(Ns_out) = s
N(Ns_out) = sigma*NN_temp
m(Ns_out) = mp + mz * int((L+1),2) + int(5*(L+1)**2,2)
end if

end do


end if
end if



end do 

end subroutine











subroutine make_m_t_p_z_basis(L,Nup,pblock,zblock,kblock,a,N,m,basis,Ns,Ns_out)
implicit none
real(kind=8), parameter :: pi = 4.0d0*datan(1.0d0)
integer(kind=4), intent(in) :: L,Nup,pblock,zblock,kblock,a,Ns
integer(kind=4), intent(inout) ,dimension(Ns) :: basis
integer(kind=1), intent(inout), dimension(Ns) :: N
integer(kind=2), intent(inout), dimension(Ns) :: m
integer(kind=4), intent(out) :: Ns_out
integer(kind=8), external :: zext
integer(kind=8) :: s_8
logical(kind=4) :: stp
real(kind=8) :: n1,n2,n3,n4
integer(kind=4) :: s,t,i
integer(kind=2) :: mp,mz,mpz
integer(kind=1) :: NN_temp,NN,sigma,sigma_i,sigma_f

if(dabs(dsin(2*kblock*a*pi/L)) .le. epsilon(1.0d0)) then
sigma_i=1
sigma_f=1
else
sigma_i=-1
sigma_f=1
end if


s=0
do i=0,Nup-1
s = ibset(s,i)
end do


Ns_out = 0

stp=.false.
do while(.not.stp)

s_8 = zext(s)
call CheckState_t_p_z(s_8,L,kblock,a,NN,mp,mz,mpz)

if (NN .ge. 0) then
if((mp .eq. -1) .and. (mz .eq. -1) .and. (mpz .eq. -1)) then

do sigma=sigma_i,sigma_f,2
Ns_out = Ns_out + 1
basis(Ns_out) = s
N(Ns_out) = sigma*NN
m(Ns_out) = int((L+1)**2,2)
end do

else if((mp .ne. -1) .and. (mz .eq. -1) .and. (mpz .eq. -1)) then

do sigma=sigma_i,sigma_f,2
NN_temp = NN

n1=1.0d0 + sigma*pblock*dcos(2*kblock*mp*a*pi/L)
n2=1.0d0 - sigma*pblock*dcos(2*kblock*mp*a*pi/L)

if (n1  .eq. 0.0d0) NN_temp = -1
if((sigma .eq. -1) .and. (n2 .ne. 0.0d0)) NN_temp = -1

if(NN_temp .ge. 0) then
Ns_out = Ns_out + 1
basis(Ns_out) = s
N(Ns_out) = sigma*NN_temp
m(Ns_out) = mp + int(2*(L+1)**2,2)
end if
end do

else if((mp .eq. -1) .and. (mz .ne. -1) .and. (mpz .eq. -1)) then

do sigma=sigma_i,sigma_f,2
NN_temp=NN
n1=1.0d0 + zblock*dcos(2*kblock*mz*a*pi/L)
if ( n1 .eq. 0.0d0) NN_temp = -1

if(NN_temp .ge. 0) then
Ns_out = Ns_out + 1
basis(Ns_out) = s
N(Ns_out) = sigma*NN_temp
m(Ns_out) = mz*int(L+1,2) + int(3*(L+1)**2,2)
end if
end do

else if((mp .eq. -1) .and. (mz .eq. -1) .and. (mpz .ne. -1)) then

do sigma=sigma_i,sigma_f,2
NN_temp = NN

n1=1.0d0 + sigma*zblock*pblock*dcos(2*kblock*mpz*a*pi/L)
n2=1.0d0 - sigma*zblock*pblock*dcos(2*kblock*mpz*a*pi/L)
if (n1  .eq. 0.0d0) NN_temp = -1
if((sigma .eq. -1) .and. (n2 .ne. 0.0d0)) NN_temp = -1

if(NN_temp .ge. 0) then
Ns_out = Ns_out + 1
basis(Ns_out) = s
N(Ns_out) = sigma*NN_temp
m(Ns_out) = mpz + int(4*(L+1)**2,2)
end if
end do

else if((mp .ne. -1) .and. (mz .ne. -1)) then

do sigma=sigma_i,sigma_f,2
NN_temp = NN

n1=1.0d0 + zblock*dcos(2*kblock*mz*a*pi/L)
n2=1.0d0 + sigma*pblock*dcos(2*kblock*mp*a*pi/L)
n3=1.0d0 - zblock*dcos(2*kblock*mz*a*pi/L)
n4=1.0d0 - sigma*pblock*dcos(2*kblock*mp*a*pi/L)

if((n1  .eq. 0.0d0) .or. (n2  .eq. 0.0d0)) NN_temp = -1
if((sigma .eq. -1) .and. ((n3 .ne. 0.0d0) .or. (n4 .ne. 0.0d0))) NN_temp = -1

if(NN_temp .ge. 0) then
Ns_out = Ns_out + 1
basis(Ns_out) = s
N(Ns_out) = sigma*NN_temp
m(Ns_out) = mp + mz * int((L+1),2) + int(5*(L+1)**2,2)
end if

end do


end if
end if

stp = btest(s,L-1)
do i=1,Nup-1
stp = stp .and. btest(s,L-1-i)
end do

t=ior(s,s-1)
s=ior(t+1,ishft(iand(not(t),-not(t))-1,-trailz(s)-1))
end do


end subroutine

