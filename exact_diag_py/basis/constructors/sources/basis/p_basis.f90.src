subroutine CheckState_P(s,L,p,r)
implicit none
integer(kind=8), intent(in) :: s
integer(kind=4), intent(in) :: L,p
integer(kind=1), intent(out) :: r
integer(kind=8) :: t
t=s
call flip_lr_64(t,L)
if(t .eq. s) then
if(p .ne. -1) then
r=4; return
else
r=-1; return
end if
else if(t .gt. s) then
r=2; return
else
r=-1; return
end if

end subroutine



subroutine make_p_basis(L,pblock,N,basis,Ns,Ns_out)
implicit none
integer(kind=4), intent(in) :: L,pblock,Ns
integer(kind=4), intent(inout), dimension(Ns) :: basis
integer(kind=1), intent(inout), dimension(Ns) :: N
integer(kind=4), intent(out) :: Ns_out
integer(kind=8), external :: zext
integer(kind=8) :: s_8
integer(kind=4) :: s,i,f
integer(kind=1) :: r

if(L == 32) then
i = -huge(1) -1
f = huge(1)
else
i = 0
f = ishft(1,L) - 1
end if


Ns_out = 0
do s=i,f
s_8 = zext(s)
call CheckState_p(s_8,L,pblock,r)
if(r.ge.0) then
Ns_out = Ns_out + 1
basis(Ns_out) = s
N(Ns_out) = r
end if
end do 

end subroutine











subroutine make_m_p_basis(L,Nup,pblock,N,basis,Ns,Ns_out)
implicit none
integer(kind=4), intent(in) :: L,Nup,pblock,Ns
integer(kind=4), intent(inout) ,dimension(Ns) :: basis
integer(kind=1), intent(inout), dimension(Ns) :: N
integer(kind=4), intent(out) :: Ns_out
integer(kind=8), external :: zext
logical(kind=4) :: stp
integer(kind=4) :: s,t,i
integer(kind=8) :: s_8
integer(kind=1) :: r

s=0
do i=0,Nup-1
s = ibset(s,i)
end do


Ns_out = 0
if(Nup.eq.0.or.Nup.eq.L) then
s_8 = zext(s)
call CheckState_p(s_8,L,pblock,r)
if(r.ge.0) then
Ns_out = Ns_out + 1
basis(Ns_out) = s
N(Ns_out) = r
end if

return

end if


stp=.false.
do while(.not.stp)
s_8 = zext(s)

call CheckState_p(s_8,L,pblock,r)
if(r.ge.0) then
Ns_out = Ns_out + 1
basis(Ns_out) = s
N(Ns_out) = r
end if

stp = btest(s,L-1)
do i=1,Nup-1
stp = stp .and. btest(s,L-1-i)
end do

t=ior(s,s-1)
s=ior(t+1,ishft(iand(not(t),-not(t))-1,-trailz(s)-1))

end do


end subroutine





