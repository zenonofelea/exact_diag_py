
subroutine refstate_p(s,L,q)
implicit none
integer(kind=4), intent(in) :: L
integer(kind=8), intent(inout) :: s
integer(kind=4), intent(out) :: q
integer(kind=8) :: r

q=0
r = s
call flip_lr_64(r,L)
if(r.lt.s) then
q = 1;s = r;
end if

end subroutine







subroutine <name=s,d,c,z>_p_op(N,basis,opstr,indx,N_indx,Ns,L,pblock,col,ME,error)
implicit none
integer(kind=4), intent(in) :: Ns, N_indx, L, pblock
integer(kind=4), intent(in), dimension(N_indx) :: indx
character, intent(in), dimension(N_indx) :: opstr
integer(kind=4), intent(in), dimension(Ns) :: basis
integer(kind=1), intent(in), dimension(Ns) :: N
integer(kind=4), intent(out), dimension(Ns) :: col
<real(kind=4),real(kind=8),complex(kind=4),complex(kind=8)>, intent(out), dimension(Ns) :: ME
integer(kind=4), intent(out) :: error
integer(kind=4), external :: FindZstate,zrm
integer(kind=8), external :: zext
integer(kind=8) :: s_8
integer(kind=4) :: i,q,s


call <name>_spinop(basis,Ns,opstr,indx,N_indx,col,ME,error)

if(error .ne. 0) return

do i=1,Ns

s_8 = zext(col(i))
call refstate_p(s_8,L,q)
s = zrm(s_8)
s = FindZstate(basis,Ns,s)
col(i)=s
if(s .gt. 0) then
ME(i)=ME(i)*(pblock**q)*<,d,,d>sqrt(<convert=float,dble,float,dble>(N(s))/<convert>(N(i)))
end if

end do

end subroutine






